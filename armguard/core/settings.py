"""
Django settings for core project.

Generated by 'django-admin startproject' using Django 5.2.7.

For more information on this file, see
https://docs.djangoproject.com/en/5.2/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/5.2/ref/settings/
"""
import os
from pathlib import Path
from decouple import config, Csv
import platform
import logging

# Logging (early initialization for settings diagnostics)
logger = logging.getLogger("core.settings")

# Optional imports with graceful fallbacks
try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    psutil = None
    PSUTIL_AVAILABLE = False
    logger.warning("psutil not available - using fallback system monitoring")

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent

# ============================================================================
# Raspberry Pi 4B Detection and Optimization
# ============================================================================

def detect_raspberry_pi():
    """Detect if running on Raspberry Pi"""
    try:
        with open('/proc/device-tree/model', 'r') as f:
            model = f.read().strip('\x00')
            return 'Raspberry Pi' in model
    except (FileNotFoundError, PermissionError):
        return False

def get_rpi_thermal_state():
    """Get RPi thermal state for monitoring"""
    try:
        import subprocess
        result = subprocess.run(['vcgencmd', 'measure_temp'], capture_output=True, text=True)
        if result.returncode == 0:
            temp_str = result.stdout.strip().replace("temp=", "").replace("'C", "")
            return float(temp_str)
    except (FileNotFoundError, subprocess.SubprocessError, ValueError):
        pass
    return None

def get_memory_info():
    """Get system memory information"""
    if not PSUTIL_AVAILABLE:
        # Fallback values when psutil is not available
        return {'total_gb': 4, 'available_gb': 2, 'percent_used': 50}
    
    try:
        memory = psutil.virtual_memory()
        return {
            'total_gb': memory.total / (1024**3),
            'available_gb': memory.available / (1024**3),
            'percent_used': memory.percent
        }
    except:
        return {'total_gb': 4, 'available_gb': 2, 'percent_used': 50}

# RPi Detection
IS_RASPBERRY_PI = detect_raspberry_pi()
MEMORY_INFO = get_memory_info()

# RPi-specific settings
if IS_RASPBERRY_PI:
    logger.info("Raspberry Pi detected - Applying ARM64 optimizations")
    logger.info(
        "Memory: %.1fGB total, %.1fGB available",
        MEMORY_INFO['total_gb'],
        MEMORY_INFO['available_gb']
    )
    
    # Thermal monitoring
    temp = get_rpi_thermal_state()
    if temp:
        logger.info("Current temperature: %.1f°C", temp)
        if temp > 70:
            logger.warning("High temperature detected")

# ============================================================================
# Core Django Settings
# ============================================================================


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.2/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
# For development: generate with: python -c "from django.core.management.utils import get_random_secret_key; print(get_random_secret_key())"
SECRET_KEY = config('DJANGO_SECRET_KEY')  # No default - must be set in .env

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = config('DJANGO_DEBUG', default=False, cast=bool)

ALLOWED_HOSTS = config('DJANGO_ALLOWED_HOSTS', default='127.0.0.1,localhost,192.168.68.129,192.168.56.1,192.168.42.1,192.168.59.1,192.168.0.177,ubuntu.local,armguard.rds,testserver', cast=Csv())

# Reverse Proxy Configuration (for Nginx)
USE_X_FORWARDED_HOST = True
USE_X_FORWARDED_PORT = True
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# CSRF Trusted Origins (for production deployments behind Nginx)
CSRF_TRUSTED_ORIGINS = [
    'http://localhost',
    'http://127.0.0.1',
    'http://192.168.0.177',
    'https://192.168.0.177',
    'http://ubuntu.local',
    'https://ubuntu.local',
    'http://192.168.68.129',
    'https://192.168.68.129',
    'http://192.168.56.1',
    'https://192.168.56.1',
    'http://192.168.42.1',
    'https://192.168.42.1',
    'http://192.168.59.1',
    'https://192.168.59.1',
]

# Add any additional CSRF trusted origins from environment
if config('CSRF_TRUSTED_ORIGINS', default=''):
    CSRF_TRUSTED_ORIGINS.extend(config('CSRF_TRUSTED_ORIGINS', cast=Csv()))


# Application definition

INSTALLED_APPS = [
    'daphne',  # Must be first for Django Channels WebSocket support
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    # Security Apps
    'axes',  # Failed login attempt tracking
    # History tracking
    'simple_history',  # Field-level change tracking
    # ArmGuard Apps
    'core',  # Added to register template tags
    'admin.apps.AdminConfig',
    'users',
    'personnel',
    'inventory',
    'transactions',
    'qr_manager',
    'print_handler',
    # VPN Integration
    'vpn_integration',
    # Real-time features
    'channels',  # Django Channels for WebSocket support
]

MIDDLEWARE = [
    # Django Core Security (Must be first)
    'django.middleware.security.SecurityMiddleware',
    
    # Static Files (WhiteNoise)
    'whitenoise.middleware.WhiteNoiseMiddleware',
    
    # Performance Optimizations (Early in stack)
    'core.middleware.performance.PerformanceOptimizationMiddleware',  # Response caching & compression
    'core.middleware.performance.DatabaseQueryOptimizationMiddleware',  # Query monitoring
    'core.middleware.performance.StaticFileOptimizationMiddleware',  # Static file optimization
    
    # Enhanced Security Headers (Early in the stack)
    'core.middleware.SecurityHeadersMiddleware',  # Enhanced CSP and security headers
    
    # Session Management
    'django.contrib.sessions.middleware.SessionMiddleware',
    'core.middleware.SingleSessionMiddleware',  # Single session enforcement
    
    # Core Django Middleware
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    
    # Audit Context Management (requires authentication)
    'core.middleware.audit_middleware.CurrentRequestMiddleware',  # Thread-local request storage
    'core.middleware.audit_middleware.AuditContextMiddleware',   # Automatic audit context
    
    # History tracking (requires authentication)
    'simple_history.middleware.HistoryRequestMiddleware',  # Automatic user tracking for history
    
    # Security Logging and Monitoring
    'core.middleware.RequestLoggingMiddleware',  # Security request logging
    
    # Message Framework
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    
    # Security Enforcement Middleware
    'axes.middleware.AxesMiddleware',  # Failed login attempt tracking
    'core.middleware.RateLimitMiddleware',  # Rate limiting protection
    'core.middleware.StripSensitiveHeadersMiddleware',  # Remove sensitive headers
    
    # Device and Network Access Control
    'core.middleware.DeviceAuthorizationMiddleware',  # Device-based authorization
    'core.network_middleware.NetworkBasedAccessMiddleware',  # LAN/WAN access control
    'vpn_integration.core_integration.vpn_middleware.VPNAwareNetworkMiddleware',  # VPN integration
    'core.network_middleware.UserRoleNetworkMiddleware',  # User role network restrictions
]

# Disable history tracking with SQLite to prevent database locks
if DEBUG or 'sqlite' in config('DB_ENGINE', default='django.db.backends.sqlite3'):
    MIDDLEWARE = [m for m in MIDDLEWARE if 'HistoryRequestMiddleware' not in m]
    logger.warning("[WARNING] HistoryRequestMiddleware disabled (SQLite or DEBUG mode) to prevent database locks")

ROOT_URLCONF = 'core.urls'

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [BASE_DIR / 'core' / 'templates'],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
                'core.network_context.network_context',  # Network access context
                'vpn_integration.core_integration.vpn_context.vpn_context',  # VPN access context
                'admin.permissions.restricted_admin_permission_check',  # Admin restriction context
            ],
        },
    },
]

WSGI_APPLICATION = 'core.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.2/ref/settings/#databases

# Enhanced Database Configuration with PostgreSQL support and Performance Optimizations
DATABASES = {
    'default': {
        'ENGINE': config('DB_ENGINE', default='django.db.backends.postgresql'),
        'NAME': config('DB_NAME', default='armguard'),
        'USER': config('DB_USER', default='armguard_user'),
        'PASSWORD': config('DB_PASSWORD', default=''),
        'HOST': config('DB_HOST', default='localhost'),
        'PORT': config('DB_PORT', default='5432', cast=int),
        'OPTIONS': {
            'connect_timeout': 20,
            'sslmode': config('DB_SSL_MODE', default='prefer'),  # SSL connection security
            # Performance Optimizations
            'MAX_CONNS': config('DB_MAX_CONNS', default=100, cast=int),  # Connection pooling
            'cursor_factory': 'psycopg2.extras.RealDictCursor',  # Faster query results
            'isolation_level': 'psycopg2.extensions.ISOLATION_LEVEL_READ_COMMITTED',
        },
        'CONN_MAX_AGE': config('DB_CONN_MAX_AGE', default=600, cast=int),  # Extended connection pooling
        'CONN_HEALTH_CHECKS': True,  # Connection health checks
    }
}

# Fallback to SQLite for development if PostgreSQL not configured
if not config('DB_PASSWORD', default=''):
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.sqlite3',
            'NAME': BASE_DIR / 'db.sqlite3',
            'OPTIONS': {
                'timeout': 30,  # Increased from 20 to prevent hangs
                'check_same_thread': False,
                'isolation_level': None,  # Autocommit mode - prevents locks
            },
            'CONN_MAX_AGE': 0,  # Don't reuse connections with SQLite
        }
    }


# Password validation
# https://docs.djangoproject.com/en/5.2/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
        'OPTIONS': {
            'min_length': config('PASSWORD_MIN_LENGTH', default=8, cast=int),
        }
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]

# Authentication Backends (for Django Axes)
AUTHENTICATION_BACKENDS = [
    'axes.backends.AxesStandaloneBackend',  # Axes authentication backend
    'django.contrib.auth.backends.ModelBackend',  # Default backend
]


# ============================================================================
# Django Channels Configuration (Real-time WebSocket Support)
# ============================================================================

ASGI_APPLICATION = 'core.asgi.application'

# Import unified Redis configuration
try:
    from .redis_settings import CHANNEL_LAYERS, CACHES, WEBSOCKET_SETTINGS
    print("[OK] Using unified Redis configuration for WebSockets")
except ImportError:
    # Fallback configuration if unified Redis not available
    try:
        import redis
        # Test Redis connection
        redis_client = redis.Redis(host='127.0.0.1', port=6379, db=1, socket_connect_timeout=1)
        redis_client.ping()
        
        # Redis is available - use it for optimal WebSocket performance
        CHANNEL_LAYERS = {
            'default': {
                'BACKEND': 'channels_redis.core.RedisChannelLayer',
                'CONFIG': {
                    "hosts": [("127.0.0.1", 6379)],
                    "capacity": 300,  # Reasonable limit to prevent memory issues
                    "expiry": 60,     # Message expiry (1 minute)
                    "group_expiry": 86400,  # Group expiry (24 hours)
                    "prefix": "armguard:",  # Redis key prefix
                    "symmetric_encryption_keys": ["your-secret-key-here"],  # Optional encryption
                },
            },
        }
        print("[OK] Using Redis for WebSocket channel layer")
        
    except (ImportError, redis.exceptions.ConnectionError, redis.exceptions.TimeoutError):
        # Redis not available - use improved InMemory with limits
        CHANNEL_LAYERS = {
            'default': {
                'BACKEND': 'channels.layers.InMemoryChannelLayer',
                'CONFIG': {
                    "capacity": 100,  # Reduced capacity to prevent memory issues
                    "expiry": 30,    # Shorter expiry for memory management
                },
            },
        }
        print("[WARNING] Redis not available - using InMemory channel layer with limits")
        print("   For better WebSocket performance, install Redis: pip install redis")
        print("   Or run the unified Redis manager: deployment/unified-redis-manager.sh")


# Network-based Security Settings
# LAN/WAN hybrid architecture configuration

# Enable network-based access control
ENABLE_NETWORK_ACCESS_CONTROL = config('ENABLE_NETWORK_ACCESS_CONTROL', default=True, cast=bool)

# Port configuration for network detection
NETWORK_PORTS = {
    'lan': 8443,  # Secure LAN operations
    'wan': 443,   # WAN status checking
}

# LAN-only paths (sensitive operations)
LAN_ONLY_PATHS = [
    '/admin/',
    '/admin',
    '/transactions/qr-scanner/',
    '/transactions/create/',
    '/transactions/edit/',
    '/transactions/delete/',
    '/inventory/add/',
    '/inventory/edit/',
    '/inventory/delete/',
    '/users/register/',
]

# WAN read-only paths (status checking)
WAN_READ_ONLY_PATHS = [
    '/personnel/',
    '/inventory/',
    '/reports/',
    '/transactions/history/',
    '/status/',
]

# Network access by user role
ROLE_NETWORK_RESTRICTIONS = {
    'admin': {'lan': True, 'wan': False},  # Admins need LAN access
    'staff': {'lan': True, 'wan': True},   # Staff can use both
    'user': {'lan': False, 'wan': True},   # Users only via WAN
}

# Session timeout by network type (minutes)
SESSION_TIMEOUT = {
    'lan': 120,  # 2 hours for LAN
    'wan': 30,   # 30 minutes for WAN
}

# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'Asia/Manila'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images) with Performance Optimizations
# https://docs.djangoproject.com/en/5.2/howto/static-files/

STATIC_URL = 'static/'
STATIC_ROOT = BASE_DIR / 'staticfiles'
STATICFILES_DIRS = [BASE_DIR / 'core' / 'static']

# Static files optimization
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',
]

# Advanced static file configuration for A+ performance
STATICFILES_STORAGE = 'whitenoise.storage.CompressedManifestStaticFilesStorage'
WHITENOISE_USE_FINDERS = True
WHITENOISE_MANIFEST_STRICT = False
WHITENOISE_AUTOREFRESH = DEBUG
WHITENOISE_MAX_AGE = 31536000 if not DEBUG else 0  # 1 year cache in production
WHITENOISE_SKIP_COMPRESS_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'zip', 'gz', 'tgz', 'bz2', 'tbz', 'xz', 'br']

# Prevent compression of CSRF-sensitive content (fixes UTF-8 decoding errors)
WHITENOISE_MIMETYPES = {
    '.html': 'text/html; charset=utf-8',
    '.css': 'text/css; charset=utf-8',
    '.js': 'application/javascript; charset=utf-8',
}

# Static file compression
COMPRESS_ENABLED = not DEBUG
COMPRESS_OFFLINE = not DEBUG
COMPRESS_CSS_FILTERS = [
    'compressor.filters.css_default.CssAbsoluteFilter',
    'compressor.filters.cssmin.rCSSMinFilter',
]
COMPRESS_JS_FILTERS = [
    'compressor.filters.jsmin.JSMinFilter',
]

# Media files (User uploads - Pictures, QR Codes)
MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'core', 'media')

# Performance Optimization: Advanced Multi-Level Caching Configuration
# ARM64/RPi compatible Redis configuration - Let Redis auto-select parser
def get_redis_options():
    """Get Redis options with automatic parser selection"""
    base_options = {
        'CLIENT_CLASS': 'django_redis.client.DefaultClient',
        'PICKLE_VERSION': 2,
        'CONNECTION_POOL_KWARGS': {
            'max_connections': config('REDIS_MAX_CONNECTIONS', default=50, cast=int),
            'health_check_interval': 30,
            'retry_on_timeout': True,
        },
        'IGNORE_EXCEPTIONS': True,  # Graceful fallback
    }
    
    # Only add parser if we can confirm it works
    try:
        import redis
        # Test if we can create a connection with default settings
        # This lets Redis choose the best parser automatically
        conn = redis.Redis(decode_responses=True)
        # Don't specify parser - let Redis auto-detect best option
    except ImportError:
        pass
    
    return base_options

REDIS_OPTIONS = get_redis_options()

CACHES = {
    'default': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': config('REDIS_URL', default='redis://127.0.0.1:6379/1'),
        'OPTIONS': {
            **REDIS_OPTIONS,
        },
        'KEY_PREFIX': 'armguard',
        'TIMEOUT': config('CACHE_TIMEOUT', default=300, cast=int),  # 5 minutes default
        'VERSION': 1,
    },
    'sessions': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': config('REDIS_URL', default='redis://127.0.0.1:6379/2'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'IGNORE_EXCEPTIONS': True,
        },
        'KEY_PREFIX': 'armguard_sessions',
        'TIMEOUT': 86400,  # 24 hours for sessions
    },
    'query_cache': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': config('REDIS_URL', default='redis://127.0.0.1:6379/3'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'IGNORE_EXCEPTIONS': True,
        },
        'KEY_PREFIX': 'armguard_queries',
        'TIMEOUT': 600,  # 10 minutes for queries
    },
    'template_cache': {
        'BACKEND': 'django_redis.cache.RedisCache',
        'LOCATION': config('REDIS_URL', default='redis://127.0.0.1:6379/4'),
        'OPTIONS': {
            'CLIENT_CLASS': 'django_redis.client.DefaultClient',
            'IGNORE_EXCEPTIONS': True,
        },
        'KEY_PREFIX': 'armguard_templates',
        'TIMEOUT': 3600,  # 1 hour for templates
    }
}

# Fallback to local memory cache if Redis is unavailable
try:
    import redis
    redis.Redis(host='localhost', port=6379, db=1).ping()
    REDIS_AVAILABLE = True
except:
    REDIS_AVAILABLE = False
    
if not REDIS_AVAILABLE or not config('REDIS_URL', default=''):
    CACHES = {
        'default': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'armguard-default',
            'TIMEOUT': 300,
            'OPTIONS': {
                'MAX_ENTRIES': 1000,
            }
        },
        'sessions': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'armguard-sessions',
            'TIMEOUT': 86400,
            'OPTIONS': {
                'MAX_ENTRIES': 500,
            }
        },
        'query_cache': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'armguard-queries',
            'TIMEOUT': 600,
            'OPTIONS': {
                'MAX_ENTRIES': 2000,
            }
        },
        'template_cache': {
            'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
            'LOCATION': 'armguard-templates',
            'TIMEOUT': 3600,
            'OPTIONS': {
                'MAX_ENTRIES': 300,
            }
        }
    }

# Session Configuration with Performance Optimization
# Session Configuration - Use database backend for reliability
SESSION_ENGINE = 'django.contrib.sessions.backends.db'  # More reliable than cache
SESSION_COOKIE_NAME = 'armguard_sessionid'  # Unique session cookie name to avoid conflicts
SESSION_COOKIE_AGE = config('SESSION_COOKIE_AGE', default=3600, cast=int)  # 1 hour
SESSION_SAVE_EVERY_REQUEST = True  # CRITICAL: Reset timeout on each request to prevent premature logout
SESSION_COOKIE_HTTPONLY = True
SESSION_COOKIE_SECURE = config('SESSION_SECURE', default=False, cast=bool)
SESSION_COOKIE_SAMESITE = 'Lax'
SESSION_EXPIRE_AT_BROWSER_CLOSE = False  # Keep session alive even after browser close
SESSION_COOKIE_DOMAIN = None  # Works with localhost and 127.0.0.1
SESSION_COOKIE_PATH = '/'  # Available across entire site

# Performance: Template Caching
if not DEBUG:
    TEMPLATES[0]['APP_DIRS'] = False  # Must be False when using custom loaders
    TEMPLATES[0]['OPTIONS']['loaders'] = [
        ('django.template.loaders.cached.Loader', [
            'django.template.loaders.filesystem.Loader',
            'django.template.loaders.app_directories.Loader',
        ]),
    ]

# Performance: Email optimization
EMAIL_TIMEOUT = 10  # 10 second timeout for SMTP
EMAIL_USE_CONNECTION_POOL = True

# Performance: Disable unnecessary features in production
if not DEBUG:
    # Disable admin documentation
    INSTALLED_APPS = [app for app in INSTALLED_APPS if app != 'django.contrib.admindocs']
    
    # Optimize select_related for auth queries
    AUTH_USER_MODEL = 'auth.User'  # Explicit to avoid queries

# Default primary key field type
# https://docs.djangoproject.com/en/5.2/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'

# ArmGuard Custom Settings
LOGIN_URL = '/login/'
LOGIN_REDIRECT_URL = '/'
LOGOUT_REDIRECT_URL = '/login/'

# Date and Time Formats (Military Time)
DATE_FORMAT = 'd/m/y'
DATETIME_FORMAT = 'd/m/y H:i:s'
USE_L10N = False

# Enhanced Production Security Settings
if not DEBUG:
    # SSL/TLS Configuration
    SECURE_SSL_REDIRECT = config('SECURE_SSL_REDIRECT', default=True, cast=bool)
    SESSION_COOKIE_SECURE = config('SESSION_COOKIE_SECURE', default=True, cast=bool)
    CSRF_COOKIE_SECURE = config('CSRF_COOKIE_SECURE', default=True, cast=bool)
    SECURE_BROWSER_XSS_FILTER = True
    SECURE_CONTENT_TYPE_NOSNIFF = True
    X_FRAME_OPTIONS = 'DENY'
    SECURE_HSTS_SECONDS = config('SECURE_HSTS_SECONDS', default=31536000, cast=int)  # 1 year
    SECURE_HSTS_INCLUDE_SUBDOMAINS = True
    SECURE_HSTS_PRELOAD = True
    
    # Enhanced Security Headers
    SECURE_REFERRER_POLICY = 'same-origin'
    SECURE_CROSS_ORIGIN_OPENER_POLICY = 'same-origin'
    
    # Additional Production Settings
    ALLOWED_HOSTS = config('DJANGO_ALLOWED_HOSTS', cast=Csv())
    
    # Database Connection Pool Settings (Production)
    if 'postgresql' in DATABASES['default']['ENGINE']:
        DATABASES['default']['CONN_MAX_AGE'] = 600  # 10 minutes
        DATABASES['default']['OPTIONS'].update({
            'MAX_CONNS': 20,
            'connect_timeout': 10,
        })

# Enhanced File Upload Security
FILE_UPLOAD_MAX_MEMORY_SIZE = config('FILE_UPLOAD_MAX_MEMORY_SIZE', default=5242880, cast=int)  # 5MB
DATA_UPLOAD_MAX_MEMORY_SIZE = config('DATA_UPLOAD_MAX_MEMORY_SIZE', default=5242880, cast=int)  # 5MB
FILE_UPLOAD_PERMISSIONS = 0o644
ALLOWED_IMAGE_EXTENSIONS = ['jpg', 'jpeg', 'png', 'gif']
ALLOWED_DOCUMENT_EXTENSIONS = ['pdf', 'doc', 'docx', 'txt']

# Enhanced Session Security (Settings moved to line 553-560 - this section is redundant)

# CSRF Protection
CSRF_COOKIE_HTTPONLY = False  # Must be False for JavaScript access to CSRF token
CSRF_COOKIE_SAMESITE = config('CSRF_COOKIE_SAMESITE', default='Lax')
CSRF_USE_SESSIONS = False  # Store CSRF token in cookies, not sessions

# Rate Limiting Configuration
RATELIMIT_ENABLE = config('RATELIMIT_ENABLE', default=True, cast=bool)
RATELIMIT_REQUESTS_PER_MINUTE = config('RATELIMIT_REQUESTS_PER_MINUTE', default=60, cast=int)

# Django Axes Configuration (Failed Login Protection)
AXES_ENABLED = config('AXES_ENABLED', default=True, cast=bool)
AXES_FAILURE_LIMIT = config('AXES_FAILURE_LIMIT', default=5, cast=int)
AXES_COOLOFF_TIME = config('AXES_COOLOFF_TIME', default=1, cast=int)  # Hours
AXES_LOCKOUT_PARAMETERS = [["username", "ip_address"]]  # Lock by username AND IP
AXES_RESET_ON_SUCCESS = True
AXES_ONLY_ADMIN_SITE = False  # Protect all login views
AXES_ENABLE_ACCESS_FAILURE_LOG = True

# Note: Cache Configuration is defined earlier with performance optimizations
# This section kept for reference but not overriding

# Admin URL Configuration
ADMIN_URL_PREFIX = config('DJANGO_ADMIN_URL', default='superadmin')

# =============================================================================
# VPN INTEGRATION SETTINGS
# =============================================================================

# Enable/disable VPN integration
WIREGUARD_ENABLED = config('WIREGUARD_ENABLED', default=False, cast=bool)
WIREGUARD_INTERFACE = config('WIREGUARD_INTERFACE', default='wg0')
WIREGUARD_NETWORK = config('WIREGUARD_NETWORK', default='10.0.0.0/24')
WIREGUARD_PORT = config('WIREGUARD_PORT', default=51820, cast=int)

# VPN Role-based access configuration
VPN_ROLE_RANGES = {
    'commander': {
        'ip_range': ('10.0.0.10', '10.0.0.19'),
        'access_level': 'VPN_INVENTORY_VIEW',
        'session_timeout': 7200,  # 2 hours
        'description': 'Commander remote inventory access'
    },
    'armorer': {
        'ip_range': ('10.0.0.20', '10.0.0.39'),
        'access_level': 'VPN_INVENTORY_VIEW',
        'session_timeout': 3600,  # 1 hour
        'description': 'Armorer remote inventory access'
    },
    'emergency': {
        'ip_range': ('10.0.0.40', '10.0.0.49'),
        'access_level': 'VPN_INVENTORY_LIMITED',
        'session_timeout': 1800,  # 30 minutes
        'description': 'Emergency limited inventory access'
    },
    'personnel': {
        'ip_range': ('10.0.0.50', '10.0.0.199'),
        'access_level': 'VPN_STATUS_ONLY',
        'session_timeout': 900,  # 15 minutes
        'description': 'Personnel status checking only'
    }
}

# VPN rate limiting (requests per minute by role)
VPN_RATE_LIMITS = {
    'commander': 100,
    'armorer': 50,
    'emergency': 200,
    'personnel': 30
}

# VPN Email alerts
VPN_EMAIL_ALERTS_ENABLED = config('VPN_EMAIL_ALERTS_ENABLED', default=False, cast=bool)
VPN_ALERT_EMAILS = config('VPN_ALERT_EMAILS', default='', cast=Csv())

# VPN Maximum concurrent connections
VPN_MAX_CONCURRENT_CONNECTIONS = config('VPN_MAX_CONCURRENT_CONNECTIONS', default=50, cast=int)

# Cache Configuration (for rate limiting and security)
# Note: Cache configuration already defined with performance optimizations above

# Security Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,
    'formatters': {
        'detailed': {
            'format': '{asctime} {levelname} {name} {process:d} {thread:d} {message}',
            'style': '{',
        },
        'security': {
            'format': '{asctime} [SECURITY] {levelname} {name}: {message}',
            'style': '{',
        },
    },
    'handlers': {
        'security_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',
            'filename': BASE_DIR / 'logs' / 'security.log',
            'maxBytes': 10485760,  # 10MB
            'backupCount': 5,
            'formatter': 'security',
        },
        'console': {
            'level': 'INFO',
            'class': 'logging.StreamHandler',
            'formatter': 'detailed',
        },
    },
    'loggers': {
        'core.security_middleware': {
            'handlers': ['security_file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'core.rate_limiting': {
            'handlers': ['security_file', 'console'],
            'level': 'WARNING',
            'propagate': True,
        },
        'admin.permissions': {
            'handlers': ['security_file', 'console'],
            'level': 'INFO',
            'propagate': True,
        },
        'axes': {
            'handlers': ['security_file', 'console'],
            'level': 'WARNING',
            'propagate': True,
        },
    },
}

# Performance: Query optimization and monitoring (after LOGGING is defined)
if DEBUG:
    # Enable query logging in development
    LOGGING['loggers']['django.db.backends'] = {
        'level': 'DEBUG',
        'handlers': ['console'],
        'propagate': False,
    }

# ============================================================================
# Raspberry Pi 4B Specific Optimizations
# ============================================================================

if IS_RASPBERRY_PI:
    # Memory optimization for RPi
    if MEMORY_INFO['total_gb'] < 2:
        logger.info("Applying low-memory optimizations for RPi")
        # Reduce database connections
        DATABASES['default']['CONN_MAX_AGE'] = 60  # Shorter connection lifetime
        # Only apply PostgreSQL-specific options if using PostgreSQL
        if 'postgresql' in DATABASES['default']['ENGINE']:
            if 'OPTIONS' not in DATABASES['default']:
                DATABASES['default']['OPTIONS'] = {}
            DATABASES['default']['OPTIONS']['MAX_CONNS'] = 5  # Fewer connections
        
        # Use simple cache backend
        CACHES['default']['BACKEND'] = 'django.core.cache.backends.dummy.DummyCache'
    
    elif MEMORY_INFO['total_gb'] < 4:
        logger.info("Applying moderate optimizations for RPi")
        # Standard optimizations for 2-4GB RPi
        DATABASES['default']['CONN_MAX_AGE'] = 300
        # Only apply PostgreSQL-specific options if using PostgreSQL
        if 'postgresql' in DATABASES['default']['ENGINE']:
            if 'OPTIONS' not in DATABASES['default']:
                DATABASES['default']['OPTIONS'] = {}
            DATABASES['default']['OPTIONS']['MAX_CONNS'] = 10
    
    # ARM64-specific file handling
    FILE_UPLOAD_MAX_MEMORY_SIZE = min(FILE_UPLOAD_MAX_MEMORY_SIZE, 2 * 1024 * 1024)  # 2MB max
    DATA_UPLOAD_MAX_MEMORY_SIZE = min(DATA_UPLOAD_MAX_MEMORY_SIZE, 2 * 1024 * 1024)  # 2MB max
    
    # Optimize static file serving
    STATICFILES_STORAGE = 'django.contrib.staticfiles.storage.StaticFilesStorage'
    
    # RPi-specific security settings
    SESSION_COOKIE_AGE = min(SESSION_COOKIE_AGE, 1800)  # 30 minutes max on RPi
    
    # Thermal monitoring integration
    RPi_THERMAL_WARNING_TEMP = 70.0  # Celsius
    RPi_THERMAL_CRITICAL_TEMP = 80.0  # Celsius
    
    # GPIO monitoring (if available)
    try:
        import RPi.GPIO as GPIO
        RPi_GPIO_AVAILABLE = True
        logger.info("RPi.GPIO available for hardware monitoring")
    except ImportError:
        RPi_GPIO_AVAILABLE = False
    
    # Logging optimization for SD card
    for handler_name, handler_config in LOGGING['handlers'].items():
        if 'filename' in handler_config:
            # Reduce log rotation frequency to preserve SD card
            handler_config['maxBytes'] = 5 * 1024 * 1024  # 5MB max
            handler_config['backupCount'] = 2  # Keep only 2 backups

# ARM64 Architecture Optimizations (for all ARM64 systems)
if platform.machine() in ['aarch64', 'arm64']:
    logger.info("Applying ARM64 architecture optimizations")
    
    # Optimize for ARM64 architecture
    DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'
    
    # ARM64-specific middleware ordering (optimized for ARM performance)
    MIDDLEWARE = [mw for mw in MIDDLEWARE if 'DeviceAuthorizationMiddleware' in mw or 
                  not any(skip in mw for skip in ['RateLimitMiddleware'] if MEMORY_INFO['total_gb'] < 1)]
    
    # ARM64 cache configuration
    if platform.machine() == 'aarch64' and MEMORY_INFO['total_gb'] >= 4:
        # Use Redis for 4GB+ ARM64 systems
        CACHES = {
            'default': {
                'BACKEND': 'django_redis.cache.RedisCache',
                'LOCATION': 'redis://127.0.0.1:6379/1',
                'OPTIONS': {
                    'CLIENT_CLASS': 'django_redis.client.DefaultClient',
                    'CONNECTION_POOL_KWARGS': {'max_connections': 10},
                },
                'KEY_PREFIX': 'armguard_rpi',
                'TIMEOUT': 300,
            }
        }

# Final RPi status report
if IS_RASPBERRY_PI:
    logger.info("Raspberry Pi optimizations applied successfully")
    logger.info(
        "Configuration: %s mode",
        'Low-memory' if MEMORY_INFO['total_gb'] < 2 else 'Standard'
    )
    
    # Create RPi monitoring function
    def get_rpi_status():
        """Get comprehensive RPi status"""
        status = {
            'temperature': get_rpi_thermal_state(),
            'memory': MEMORY_INFO,
            'platform': platform.platform(),
            'architecture': platform.machine(),
        }
        return status
    
    # Thermal protection middleware integration
    def thermal_protection_check():
        """Check for thermal throttling and adjust performance"""
        thermal_temp = get_rpi_thermal_state()
        if thermal_temp and thermal_temp > RPi_THERMAL_CRITICAL_TEMP:
            # Enable thermal protection mode
            import os
            os.environ['DJANGO_THERMAL_PROTECTION'] = 'true'
            logger.warning("THERMAL PROTECTION: Activated at %.1f°C", thermal_temp)
            return True
        return False
    
    # Make functions available globally
    globals()['get_rpi_status'] = get_rpi_status
    globals()['thermal_protection_check'] = thermal_protection_check
    
    # Run initial thermal check
    thermal_protection_check()

# ARM64/RPi deployment completion marker
logger.info("ArmGuard Configuration: 100% RASPBERRY PI 4B READY")
logger.info("Deployment Guide: See RPi_DEPLOYMENT_COMPLETE.md")
logger.info("Validation: Run python validate_deployment.py")

# Create logs directory if it doesn't exist
import os
os.makedirs(BASE_DIR / 'logs', exist_ok=True)

# User Registration Configuration
# SECURITY: Disabled by default for military systems - only admins can create accounts
ALLOW_PUBLIC_REGISTRATION = config('ALLOW_PUBLIC_REGISTRATION', default=False, cast=bool)

# ============================================================================
# WebSocket Connection Management Settings
# Configuration for optimal WebSocket performance and connection limits
# ============================================================================

WEBSOCKET_CONNECT_TIMEOUT = 5  # seconds
WEBSOCKET_DISCONNECT_TIMEOUT = 3  # seconds  
WEBSOCKET_MAX_CONNECTIONS_PER_USER = 3  # Limit concurrent connections

# WebSocket close codes for better error handling
WEBSOCKET_CLOSE_CODES = {
    'UNAUTHORIZED': 4001,
    'SERVER_ERROR': 4000,
    'RATE_LIMITED': 4029,
    'CONNECTION_LIMIT': 4030
}
